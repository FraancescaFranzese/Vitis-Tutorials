%
% Copyright (C) 2024, Advanced Micro Devices, Inc. All rights reserved.
% SPDX-License-Identifier: MIT
%
% Author: Richard Buz

% Generates test vector files, for a single image, which are used to verify 
% bilinear interpolation performed via AIE simulation.

% Inputs to the function are:
%        cores:   Specifies the number of parallel bilinear interpolation
%                 kernels. Test vector input and output is generated for 
%                 each individual kernel. The default value is 1.
%        npxl:    Number of pixels processed per AIE kernel invocation.
%                 Must be a multiple of 8. The default is 256.
%        frmslct: This is an index used to select an individual image frame
%                 from file bli_coords.mat. The default is 40.

% Generated files: Files are created in directory ../aie/data/
%
%        Three input files are generated for each individual kernel, The
%        naming convention is input_1_A.txt, input_1_B.txt, input_1_C.txt,
%        input_2_A.txt, input_2_B.txt, input_2_C.txt, ...
%        Pixels are processed in groups of 8, and each interpolated pixel
%        is associated with a sequence of six values. The order of input 
%        data is: 8x xfrac and 8x yfrac in file A, 8x pixel P11 and 8x
%        pixel P12 in file B, 8x pixel P21 and 8x pixel P22 in file C.
%
%        An output file is generated for each kernel and is used to compare
%        with AIE output. The naming convention is output_1_ref.txt,
%        output_2_ref.txt, output_3_ref.txt, ...
%        Each file consists of a sequence of interpolated pixel values. 
% 
%        For all files, floating point values are cast as 'int32' so they 
%        can be written to text files without loss of precision.
%
%        An additional file named config.h is also generated in directory 
%        ../aie/src, and is necessary to compile the AIE code. The file
%        contains three macro definitions. The first specifies the number
%        of parallel cores used. The second specifies the input buffer size. 
%        The third specifies the number of times the graph needs to be run 
%        to process the entire image.


% NOTE:
% This Matlab script has been modified compared to the original version.
% The input vectors use data in the int16 format. The original example uses the 
% float data type. 

function genvectors_bilinear_interp(cores, npxl, frmslct)

% assign default arguments if necessary
if nargin < 3
    frame_select = 40;
else
    frame_select = frmslct;
end

if nargin < 2
    numpxl = 256;
else
    numpxl = npxl;
end

if nargin == 0
    ncore = 1;
else
    ncore = cores;
end

% check numpxl is a multiple of 8
if mod(numpxl,8) ~= 0
    error('ERROR: Parameter numpxl must be divisible by 8');
end

% Load data generated by image_transform.m and select a frame
load('bli_coords.mat', 'I', 'Xq', 'Yq');
Xq  = Xq(:,:,frame_select);
Yq  = Yq(:,:,frame_select);

% Use camera image as a lookup table. 
% Make indicies integers and determine the image size bounds.
[ysz, xsz] = size(I);
lut_xmin = 0;
lut_xmax = xsz - 1;
lut_ymin = 0;
lut_ymax = ysz - 1;

% Convert LUT to single precision float format and initialize output image
% to all zeros.
ImLUT = single(I(:));
ImgOut = single(zeros(size(Yq,1) * size(Xq,2), 1));
   
% AIE kernel is set to process blocks of numpxl pixels. Make sure there is
% enough input data so the simulation doesn't hang.
max_pxl_per_proc = numpxl * ceil(size(Yq,1) * size(Xq,2) / ncore / numpxl);
input_tv_A = repmat(typecast(realmax('single'), 'int32'), 2*max_pxl_per_proc, ncore);
input_tv_B = repmat(typecast(realmax('single'), 'int32'), 2*max_pxl_per_proc, ncore);
input_tv_C = repmat(typecast(realmax('single'), 'int32'), 2*max_pxl_per_proc, ncore);
output_tv = repmat(typecast(realmax('single'), 'int32'), max_pxl_per_proc, ncore);

% process the output pixels in sequence
itv_idx = 1;
otv_idx = 1;
core_idx = 1;
samp_cnt = 0;
tvx = single(zeros(8,1));
tvy = single(zeros(8,1));
tvp11 = single(zeros(8,1));
tvp12 = single(zeros(8,1));
tvp21 = single(zeros(8,1));
tvp22 = single(zeros(8,1));
tvo = single(zeros(8,1));
in_bnd_cnt = 0;

for ix = 1:size(Xq,2)
    for iy = 1:size(Yq,1)
        % get query coordinates
        xval = Xq(iy,ix);
        yval = Yq(iy,ix);

        % Points requiring extrapolation are set to zero.
        is_interp = xval >= lut_xmin && xval < lut_xmax && yval >= lut_ymin && yval < lut_ymax;

        if is_interp
            % get reference point data from camera image
            x1 = int32(floor(xval));
            y1 = int32(floor(yval));   

            % four values used in interpolation, taken from camera image
            P11 = ImLUT(x1*(lut_ymax+1)+y1+1);
            P12 = ImLUT(x1*(lut_ymax+1)+y1+2);
            P21 = ImLUT((x1+1)*(lut_ymax+1)+y1+1);
            P22 = ImLUT((x1+1)*(lut_ymax+1)+y1+2);

            % fractional part for interpolation
            xfrac = single(xval - floor(xval));
            yfrac = single(yval - floor(yval));
            
            in_bnd_cnt = in_bnd_cnt + 1;
        else
            P11 = single(0);
            P12 = single(0);
            P21 = single(0);
            P22 = single(0);
            xfrac = single(0);
            yfrac = single(0);
        end

        % perform bilinear interpolation
        blint_in = [P11 P12 P21 P22 xfrac yfrac];
        pxl_intrp = blint(blint_in,4);

        % write test vector data
        output_idx = int32(size(Yq,1)*(ix-1) + iy - 1);
        ImgOut(output_idx + 1) = pxl_intrp;
        tvx(mod(samp_cnt,8) + 1) = xfrac;
        tvy(mod(samp_cnt,8) + 1) = yfrac;
        tvp11(mod(samp_cnt,8) + 1) = P11;
        tvp12(mod(samp_cnt,8) + 1) = P12;
        tvp21(mod(samp_cnt,8) + 1) = P21;
        tvp22(mod(samp_cnt,8) + 1) = P22;
        tvo(mod(samp_cnt,8) + 1) = pxl_intrp;

        if mod(samp_cnt,8) == 7
            
            input_tv_A_double(itv_idx:itv_idx+15, core_idx) = [tvx; tvy];
            input_tv_B_double(itv_idx:itv_idx+15, core_idx) = [tvp11; tvp12];
            input_tv_C_double(itv_idx:itv_idx+15, core_idx) = [tvp21; tvp22];

            input_tv_A(itv_idx:itv_idx+15, core_idx) = typecast([tvx; tvy], 'int32');
            input_tv_B(itv_idx:itv_idx+15, core_idx) = typecast([tvp11; tvp12], 'int32');
            input_tv_C(itv_idx:itv_idx+15, core_idx) = typecast([tvp21; tvp22], 'int32');
            itv_idx = itv_idx + 16;
            output_tv((otv_idx:otv_idx+7),core_idx) = typecast(tvo, 'int32');

            output_tv_double((otv_idx:otv_idx+7),core_idx) = tvo;

            otv_idx = otv_idx + 8;
        end

        % update counters
        samp_cnt = samp_cnt + 1;

        if samp_cnt == max_pxl_per_proc
            samp_cnt = 0;
            core_idx = core_idx + 1;
            itv_idx = 1;
            otv_idx = 1;
        end
    end
end

% int16 conversion:
input_tv_A_int16 = int16(input_tv_A_double);
input_tv_B_int16 = int16(input_tv_B_double);
input_tv_C_int16 = int16(input_tv_C_double);
output_tv_int16 = int16(output_tv_double);

% determine number of kernel calls required
num_krnl_call = max_pxl_per_proc / numpxl;

% create config.h file
fid = fopen('../aie/src/config.h','w');
fprintf(fid, ['//\n// Copyright (C) 2024, Advanced Micro Devices, Inc. All ' ...
              'rights reserved.\n// SPDX-License-Identifier: MIT\n//\n' ...
              '// Author: Richard Buz\n\n#pragma once\n\n#define\tNCORE\t%d\n' ...
              '#define\tNRUN\t%d\n#define\tPXLPERGRP\t%d\n'],ncore,num_krnl_call,numpxl);
fclose(fid);

% substitution of int32 data with int16 data
input_tv_A = input_tv_A_int16;
input_tv_B = input_tv_B_int16;
input_tv_C = input_tv_C_int16;
output_tv = output_tv_int16;

% create input test vectors
for idx = 1:ncore
    fname = sprintf('../aie/data/input_%d_A.txt',idx);
    fid = fopen(fname,'w');
    if fid > 0
        itv = reshape(input_tv_A(:,idx),2,length(input_tv_A(:,idx))/2);
        fprintf(fid,'%d %d\n',itv);
        fclose(fid);
    end
end

for idx = 1:ncore
    fname = sprintf('../aie/data/input_%d_B.txt',idx);
    fid = fopen(fname,'w');
    if fid > 0
        itv = reshape(input_tv_B(:,idx),2,length(input_tv_B(:,idx))/2);
        fprintf(fid,'%d %d\n',itv);
        fclose(fid);
    end
end

for idx = 1:ncore
    fname = sprintf('../aie/data/input_%d_C.txt',idx);
    fid = fopen(fname,'w');
    if fid > 0
        itv = reshape(input_tv_C(:,idx),2,length(input_tv_C(:,idx))/2);
        fprintf(fid,'%d %d\n',itv);
        fclose(fid);
    end
end

% create output test vectors
for idx = 1:ncore
    fname = sprintf('../aie/data/output_%d_ref.txt',idx);
    fid = fopen(fname,'w');
    if fid > 0
        otv = reshape(output_tv(:,idx),2,length(output_tv(:,idx))/2);
        fprintf(fid,'%d %d\n',otv);
        fclose(fid);
    end
end

% setup comparison to MATLAB interp2 function
[Xref, Yref] = meshgrid(0:xsz-1,0:ysz-1);
Imgld = interp2(Xref,Yref,double(I),Xq,Yq,'linear',0);
ImgOut = reshape(ImgOut, size(Yq,1), size(Xq,2));
save golden_ref.mat Imgld

% display result
fprintf('Number of output pixels interpolated = %d out of %d (%8.5f %%)\n', ...
    in_bnd_cnt, size(Yq,1)*size(Xq,2), 100*in_bnd_cnt/(size(Yq,1)*size(Xq,2)));
subplot(1,3,1);
imshow(double(I)/255)
title('Camera Image')
subplot(1,3,2);
imshow(ImgOut/255)
title('Bilinear Interpolation (Int16)')
subplot(1,3,3);
imshow(Imgld/255)
title('Golden Reference (Double Precision)')

% calculate error
err = abs(ImgOut - Imgld);
max_err = max(err(:));
ms_err = mean(err(:).^2);
fprintf('Maximum pixel error is %.9f\n', max_err)
fprintf('Mean square pixel error is %.9f\n', ms_err)